// ksocket.cpp
#include "ksocket.hpp"

#include <iostream>
#include <random>
#include <chrono>
#include <thread>
#include <csignal>
#include <cstring>
#include <cerrno>
#include <sys/select.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <unistd.h>
#include <fcntl.h>

// Keep a global pointer to shared memory (same symbol name as the header)
SharedMemory* shm = nullptr;

// RNG for dropMessage
static std::mt19937 rng((std::random_device())());

// Return 1 if dropped, 0 otherwise (keeps original int signature)
int dropMessage(float probability) {
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    bool dropped = dist(rng) < static_cast<double>(probability);
    if (dropped) {
        std::cout << "[dropMessage] Packet dropped (probability=" << probability << ")\n";
    }
    return dropped ? 1 : 0;
}

int init_shared_memory() {
    std::cout << "[init_shared_memory] Initializing shared memory...\n";
    int shmid = shmget(IPC_PRIVATE, static_cast<int>(sizeof(SharedMemory)), 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("[init_shared_memory] shmget failed");
        return -1;
    }

    shm = attach_shared_memory(shmid);
    if (shm == nullptr) return -1;

    // Initialize sockets
    for (int i = 0; i < MAX_SOCKETS; ++i) {
        shm->sockets[i].is_free = 1;
        shm->sockets[i].process_id = 0;
        shm->sockets[i].sock_id = -1;
        shm->sockets[i].send_count = 0;
        shm->sockets[i].recv_count = 0;

        shm->sockets[i].swnd.base = 0;
        shm->sockets[i].swnd.next_seq = 0;
        shm->sockets[i].swnd.size = 0;
        for (int j = 0; j < WINDOW_SIZE; ++j) {
            shm->sockets[i].swnd.timestamps[j] = 0;
            shm->sockets[i].swnd.messages[j].seq_num = 0;
            shm->sockets[i].swnd.messages[j].type = 0;
            shm->sockets[i].swnd.messages[j].payload.fill(0);
        }

        shm->sockets[i].rwnd.base = 0;
        shm->sockets[i].rwnd.size = 0;
        shm->sockets[i].rwnd.rwnd = WINDOW_SIZE;
        for (int j = 0; j < WINDOW_SIZE; ++j) {
            shm->sockets[i].rwnd.messages[j].seq_num = 0;
            shm->sockets[i].rwnd.messages[j].type = 0;
            shm->sockets[i].rwnd.messages[j].payload.fill(0);
        }

        for (int j = 0; j < WINDOW_SIZE; ++j) {
            shm->sockets[i].send_buffer[j].seq_num = 0;
            shm->sockets[i].send_buffer[j].type = 0;
            shm->sockets[i].send_buffer[j].payload.fill(0);
            shm->sockets[i].recv_buffer[j].seq_num = 0;
            shm->sockets[i].recv_buffer[j].type = 0;
            shm->sockets[i].recv_buffer[j].payload.fill(0);
        }
    }

    shm->drop_probability = P_DROP;
    std::cout << "[init_shared_memory] Shared memory initialized with ID: " << shmid << "\n";
    return shmid;
}

SharedMemory* attach_shared_memory(int shmid) {
    void* ptr = shmat(shmid, nullptr, 0);
    if (ptr == reinterpret_cast<void*>(-1)) {
        perror("[attach_shared_memory] shmat failed");
        return nullptr;
    }
    std::cout << "[attach_shared_memory] Attached at " << ptr << "\n";
    return reinterpret_cast<SharedMemory*>(ptr);
}

void detach_shared_memory(SharedMemory* shm_ptr) {
    if (!shm_ptr) return;
    if (shmdt(reinterpret_cast<void*>(shm_ptr)) == -1) {
        perror("[detach_shared_memory] shmdt failed");
    } else {
        std::cout << "[detach_shared_memory] Detached successfully\n";
    }
}

void cleanup_shared_memory(int shmid) {
    if (shmctl(shmid, IPC_RMID, nullptr) == -1) {
        perror("[cleanup_shared_memory] shmctl failed");
    } else {
        std::cout << "[cleanup_shared_memory] Shared memory " << shmid << " removed\n";
    }
}

int k_socket() {
    std::cout << "[k_socket] Creating KTP socket...\n";
    if (shm == nullptr) {
        std::cerr << "[k_socket] Shared memory not attached\n";
        return -1;
    }
    pid_t pid = getpid();
    for (int i = 0; i < MAX_SOCKETS; ++i) {
        if (shm->sockets[i].is_free) {
            shm->sockets[i].is_free = 0;
            shm->sockets[i].process_id = pid;
            shm->sockets[i].swnd.base = 0;
            shm->sockets[i].swnd.next_seq = 0;
            shm->sockets[i].swnd.size = 0;
            shm->sockets[i].rwnd.base = 0;
            shm->sockets[i].rwnd.size = 0;
            shm->sockets[i].rwnd.rwnd = WINDOW_SIZE;
            std::cout << "[k_socket] Allocated socket " << i << " to PID " << pid << "\n";
            return i;
        }
    }
    std::cout << "[k_socket] No space available\n";
    return ENOSPACE;
}

int k_bind(int sockfd, const char* src_ip, int src_port, const char* dest_ip, int dest_port) {
    std::cout << "[k_bind] Binding socket " << sockfd << " to "
              << src_ip << ":" << src_port << ", dest " << dest_ip << ":" << dest_port << "...\n";

    if (shm == nullptr || sockfd < 0 || sockfd >= MAX_SOCKETS || shm->sockets[sockfd].is_free) {
        std::cerr << "[k_bind] Invalid socket\n";
        return ENOTBOUND;
    }

    shm->sockets[sockfd].src_addr.sin_family = AF_INET;
    shm->sockets[sockfd].src_addr.sin_port = htons(src_port);
    inet_pton(AF_INET, src_ip, &shm->sockets[sockfd].src_addr.sin_addr);

    shm->sockets[sockfd].dest_addr.sin_family = AF_INET;
    shm->sockets[sockfd].dest_addr.sin_port = htons(dest_port);
    inet_pton(AF_INET, dest_ip, &shm->sockets[sockfd].dest_addr.sin_addr);

    return sockfd;
}

int k_sendto(int sockfd, const void* buf, size_t len, int /*flags*/) {
    std::cout << "[k_sendto] Sending from socket " << sockfd << "...\n";

    if (shm == nullptr || sockfd < 0 || sockfd >= MAX_SOCKETS || shm->sockets[sockfd].is_free) {
        std::cerr << "[k_sendto] Invalid socket\n";
        return ENOTBOUND;
    }
    if (shm->sockets[sockfd].swnd.size >= WINDOW_SIZE) {
        std::cout << "[k_sendto] Sender window full (swnd.size=" << shm->sockets[sockfd].swnd.size
                  << ", base=" << shm->sockets[sockfd].swnd.base
                  << ", next_seq=" << shm->sockets[sockfd].swnd.next_seq << ")\n";
        return ENOSPACE;
    }
    if (shm->sockets[sockfd].send_count >= WINDOW_SIZE) {
        std::cerr << "[k_sendto] Send buffer full\n";
        return ENOSPACE;
    }

    KTP_Message msg;
    msg.seq_num = static_cast<std::uint8_t>(shm->sockets[sockfd].swnd.next_seq % 256);
    msg.type = MSG_TYPE_DATA;

    size_t copy_len = (len < static_cast<size_t>(MESSAGE_SIZE - 1)) ? len : (MESSAGE_SIZE - 1);
    // payload is an array<char, MESSAGE_SIZE>
    std::memset(msg.payload.data(), 0, MESSAGE_SIZE);
    std::memcpy(msg.payload.data(), buf, copy_len);
    msg.payload[copy_len] = '\0';

    shm->sockets[sockfd].send_buffer[shm->sockets[sockfd].send_count++] = msg;
    shm->sockets[sockfd].swnd.next_seq = (shm->sockets[sockfd].swnd.next_seq + 1) % 256;
    std::cout << "[k_sendto] Queued seq=" << static_cast<int>(msg.seq_num) << ": " << msg.payload.data() << "\n";
    return static_cast<int>(copy_len);
}

int k_recvfrom(int sockfd, void* buf, size_t len, int /*flags*/) {
    std::cout << "[k_recvfrom] Receiving on socket " << sockfd << "...\n";
    if (shm == nullptr || sockfd < 0 || sockfd >= MAX_SOCKETS || shm->sockets[sockfd].is_free) {
        std::cerr << "[k_recvfrom] Invalid socket\n";
        return ENOTBOUND;
    }
    if (shm->sockets[sockfd].recv_count > 0) {
        KTP_Message msg = shm->sockets[sockfd].recv_buffer[0];
        int msg_len = static_cast<int>(strnlen(msg.payload.data(), MESSAGE_SIZE));
        if (msg_len > static_cast<int>(len)) msg_len = static_cast<int>(len);
        std::memcpy(buf, msg.payload.data(), msg_len);

        // shift left
        for (int i = 1; i < shm->sockets[sockfd].recv_count; ++i) {
            shm->sockets[sockfd].recv_buffer[i - 1] = shm->sockets[sockfd].recv_buffer[i];
        }
        shm->sockets[sockfd].recv_count--;
        shm->sockets[sockfd].rwnd.rwnd = WINDOW_SIZE - shm->sockets[sockfd].recv_count;
        std::cout << "[k_recvfrom] Got seq=" << static_cast<int>(msg.seq_num)
                  << ": " << static_cast<char*>(buf) << ", rwnd=" << shm->sockets[sockfd].rwnd.rwnd << "\n";
        return msg_len;
    }
    std::cout << "[k_recvfrom] No message available\n";
    return ENOMESSAGE;
}

int k_close(int sockfd) {
    std::cout << "[k_close] Closing socket " << sockfd << "...\n";
    if (shm == nullptr || sockfd < 0 || sockfd >= MAX_SOCKETS || shm->sockets[sockfd].is_free) {
        std::cerr << "[k_close] Invalid socket\n";
        return ENOTBOUND;
    }
    shm->sockets[sockfd].is_free = 1;
    shm->sockets[sockfd].process_id = 0;
    shm->sockets[sockfd].send_count = 0;
    shm->sockets[sockfd].recv_count = 0;
    shm->sockets[sockfd].swnd.size = 0;
    std::cout << "[k_close] Closed socket " << sockfd << "\n";
    return 0;
}

// thread_r: handles receiving datagrams and ACKs, and updates shared memory structures
void* thread_r(void* arg) {
    ThreadArgs* args = reinterpret_cast<ThreadArgs*>(arg);
    int shmid = args->shmid;
    std::cout << "[thread_r] Starting with shmid=" << shmid << "...\n";
    shm = attach_shared_memory(shmid);
    if (shm == nullptr) return nullptr;

    int socks[MAX_SOCKETS];
    for (int i = 0; i < MAX_SOCKETS; ++i) {
        socks[i] = ::socket(AF_INET, SOCK_DGRAM, 0);
        if (socks[i] < 0) {
            perror("[thread_r] Socket creation failed");
            detach_shared_memory(shm);
            return nullptr;
        }
        sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_port = htons((i == 0) ? PORT_USER1 : PORT_USER2);
        inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
        if (bind(socks[i], reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
            perror("[thread_r] Bind failed");
            for (int j = 0; j <= i; ++j) if (socks[j] >= 0) close(socks[j]);
            detach_shared_memory(shm);
            return nullptr;
        }
        shm->sockets[i].sock_id = socks[i];
        std::cout << "[thread_r] Bound sock_" << i << "=" << socks[i] << " to 127.0.0.1:" << ntohs(addr.sin_port) << "\n";
        // make socket non-blocking optionally
        int flags = fcntl(socks[i], F_GETFL, 0);
        fcntl(socks[i], F_SETFL, flags | O_NONBLOCK);
    }

    fd_set readfds;
    timeval tv;
    while (true) {
        FD_ZERO(&readfds);
        int max_fd = 0;
        for (int i = 0; i < MAX_SOCKETS; ++i) {
            if (!shm->sockets[i].is_free) {
                FD_SET(socks[i], &readfds);
                if (socks[i] > max_fd) max_fd = socks[i];
            }
        }
        tv.tv_sec = 0;
        tv.tv_usec = 50000; // 50 ms

        int ready = select(max_fd + 1, &readfds, nullptr, nullptr, &tv);
        if (ready < 0) {
            perror("[thread_r] Select failed");
            break;
        }
        if (ready == 0) {
            // timeout - continue
            continue;
        }

        for (int i = 0; i < MAX_SOCKETS; ++i) {
            if (!shm->sockets[i].is_free && FD_ISSET(socks[i], &readfds)) {
                KTP_Message msg{};
                sockaddr_in sender{};
                socklen_t sender_len = sizeof(sender);
                ssize_t recv_len = recvfrom(socks[i], &msg, static_cast<int>(sizeof(KTP_Message)), 0,
                                            reinterpret_cast<sockaddr*>(&sender), &sender_len);
                if (recv_len <= 0) continue;

                if (dropMessage(shm->drop_probability)) {
                    std::cout << "[thread_r] Dropped packet: seq=" << static_cast<int>(msg.seq_num) << "\n";
                    continue;
                }

                int src_port = ntohs(sender.sin_port);
                int dest_sockfd = (src_port == PORT_USER1) ? 1 : 0;
                int sender_sockfd = (src_port == PORT_USER1) ? 0 : 1;

                if (msg.type == MSG_TYPE_DATA) {
                    int expected = shm->sockets[dest_sockfd].rwnd.base;
                    // handle wrapping carefully (since seq_num 0..255)
                    int seq = static_cast<int>(msg.seq_num);
                    // For simplicity, only accept if within expected .. expected+WINDOW_SIZE-1 (no wrap complicated handling)
                    if (seq >= expected && seq < expected + WINDOW_SIZE) {
                        int idx = seq - expected;
                        if (idx < WINDOW_SIZE &&
                            (idx >= shm->sockets[dest_sockfd].rwnd.size ||
                             shm->sockets[dest_sockfd].rwnd.messages[idx].seq_num != msg.seq_num)) {
                            shm->sockets[dest_sockfd].rwnd.messages[idx] = msg;
                            if (idx >= shm->sockets[dest_sockfd].rwnd.size) {
                                shm->sockets[dest_sockfd].rwnd.size = idx + 1;
                            }
                        }
                        // Move contiguous start-of-window to recv_buffer
                        while (shm->sockets[dest_sockfd].rwnd.size > 0 &&
                               shm->sockets[dest_sockfd].rwnd.messages[0].seq_num == shm->sockets[dest_sockfd].rwnd.base) {
                            if (shm->sockets[dest_sockfd].recv_count < WINDOW_SIZE) {
                                shm->sockets[dest_sockfd].recv_buffer[shm->sockets[dest_sockfd].recv_count++] =
                                    shm->sockets[dest_sockfd].rwnd.messages[0];
                            }
                            shm->sockets[dest_sockfd].rwnd.base = (shm->sockets[dest_sockfd].rwnd.base + 1) % 256;
                            for (int j = 1; j < shm->sockets[dest_sockfd].rwnd.size; ++j) {
                                shm->sockets[dest_sockfd].rwnd.messages[j - 1] =
                                    shm->sockets[dest_sockfd].rwnd.messages[j];
                            }
                            shm->sockets[dest_sockfd].rwnd.size--;
                        }
                        std::cout << "[thread_r] Received for socket " << dest_sockfd
                                  << ": seq=" << seq << ", payload=" << shm->sockets[dest_sockfd].recv_buffer[std::max(0, shm->sockets[dest_sockfd].recv_count-1)].payload.data() << "\n";
                    }

                    // Send ACK back to sender
                    KTP_Message ack{};
                    ack.type = MSG_TYPE_ACK;
                    ack.seq_num = static_cast<std::uint8_t>((shm->sockets[dest_sockfd].rwnd.base - 1 + 256) % 256);
                    int free_rwnd = WINDOW_SIZE - shm->sockets[dest_sockfd].recv_count;
                    int printed = snprintf(ack.payload.data(), MESSAGE_SIZE, "%d", free_rwnd);
                    if (printed < 0) ack.payload[0] = '\0';

                    ssize_t sent = sendto(socks[i], &ack, static_cast<int>(sizeof(KTP_Message)), 0,
                                          reinterpret_cast<sockaddr*>(&sender), sender_len);
                    if (sent < 0) {
                        perror("[thread_r] sendto (ACK) failed");
                    } else {
                        std::cout << "[thread_r] Sent ACK for socket " << dest_sockfd
                                  << ": seq=" << static_cast<int>(ack.seq_num)
                                  << ", rwnd=" << ack.payload.data() << "\n";
                    }

                } else if (msg.type == MSG_TYPE_ACK) {
                    int acked = static_cast<int>(msg.seq_num);
                    // slide sender window for sender_sockfd
                    while (shm->sockets[sender_sockfd].swnd.size > 0 &&
                           static_cast<int>(shm->sockets[sender_sockfd].swnd.messages[0].seq_num) <= acked) {
                        // shift left
                        for (int j = 1; j < shm->sockets[sender_sockfd].swnd.size; ++j) {
                            shm->sockets[sender_sockfd].swnd.messages[j - 1] =
                                shm->sockets[sender_sockfd].swnd.messages[j];
                            shm->sockets[sender_sockfd].swnd.timestamps[j - 1] =
                                shm->sockets[sender_sockfd].swnd.timestamps[j];
                        }
                        shm->sockets[sender_sockfd].swnd.size--;
